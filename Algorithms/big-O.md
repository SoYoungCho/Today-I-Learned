# big - O

- 입력값이 커질 때 (무한대로 커질 때) 함수의 **상한**을 설명하는 수학적 표기 방법
- 복잡한 알고리즘도 입력 크기가 작으면 컴퓨터가 빠르게 처리함
- 따라서 관심의 대상은 **입력의 크기가 충분히 클 때**이다
	- 입력이 클 경우 **효율성**에 따라 수행시간 차이 많이 나기 때문
- 이러한 실행시간의 추이
	- = 점근적 실행 시간
	- = 시간 복잡도
- 시간 복잡도란?
	- 어떤 알고리즘 수행시 걸리는 시간을 설명하는 계산 복잡도
	-	계산 복잡도 표기 시 상수항 무시한 최고차항만
---
- O(1)
	- 입력값이 아무리 커도 실행시간은 일정
	- best!
	- 일정한 상수시간만큼 실행된다는 것
	- but, 그 일정한 상수값이 사실 매우 크다면 의미가 없는 것이기에 신중해야
	- **해시테이블, 스택의 push, pop**
- O(log n)
	- 로그를 취하기에 큰 입력값에 대해서도 영향 많이 받지 않아서 견고함
	- **이진 검색**
- O(n)
	- 수행 시간은 입력값에 비례
	- 이러한 알고리즘을 선형 시간 (Linear-time) 알고리즘이라고 함
	- **최댓값 / 최솟값 찾기**
		- 이 경우 모든 입력값을 적어도 한번 이상 보아야
- O(n log n)
	- 효율 좋은 정렬 알고리즘이 이에 해당
	- **병합 정렬(merge sort)**
		- 절반으로 나누고 나누고 나구고.. 합치고 합치고 하는 것
- O(n^2)
	- 비효율적 정렬 알고리즘
	- **버블 정렬**
- O(2^n)
	- **피보나치 수 재귀로 계산**
	- n^2 <<<<<<<<<< 2^n임을 기억하자 (헷갈리지 말기)
- O(n!)
	- 가장 느린 알고리즘
	- **각 도시를 방문하고 돌아오는 가장 짧은 경로 찾는 외판원 문제를 브루트 포스로 풀이하는 경우**
- 시간과 공간은 trade-off 관계임을 기억!
---
### 상한과 최악을 혼동하지 말자
- 최악인 '경우' 는 시간복잡도와 상관이 없다
- 상한이란 '가장 늦게 실행될 때'를 의미.
	- 가장 늦게 실행될 때를 빅오라고 함
- 다시 말해, 빅오 표기법은 주어진 경우(최선, 최악, 평균)의 수행 시간의 상한을 나타낸다
### 분할 상환 분석
- 알고리즘 전체를 보지 않고 최악의 경우만 살펴보는 것은 지나치게 비관적임
- 따라서 최악의 경우를 여러 ㄹ번에 걸쳐 골고루 나눠주는 형태로 시간 복잡도 계산
### 병렬화
- GPU & CPU
	- 하나의 코어만 비교하면 GPU 코어가 CPU 코어보다 느리다
	- 하지만 GPU는 수천개의 코어로 구성되어서 수십개의 코어로 이루어진 CPU보다 수백 배 더 빠른 연상 동시 수행 가능
- 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 알고리즘 우수성을 평가하는 또다른 척도

출처 : 파이썬 알고리즘 인터뷰 책
